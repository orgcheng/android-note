假设AIDL文件定义了服务接口，编译后生成了`IRemoteService`文件，
生成的`IRemoteService`接口中包含抽象静态内部类`Sub`，而`Sub`内部又含有静态内部类`Sub.Proxy`，他们都实现了接口`IYourpageService`

`Sub`是供服务端使用的，服务要实现服务接口的具体功能，需要继承类`IRemoteService.Stub`，并实现抽象方法
`Sub.Proxy`是供客户端使用的，起到代理的作用，在客户端通过`Sub.Proxy.transact`方法发起事务，在远程服务器端的`Sub.onTranct`方法中处理事务

当客户端绑定远程服务时，分两种情况：
１．当客户端和服务在同一个进程中，客户端可以直接获取服务的实例
２．当客户端和服务在不同的进程中，客户端不能直接获取服务的实例，需要借助`Sub.Proxy`来实现服务调用

需要注意三点：
１．当客户端发起远程服务请求时，由于当前线程会被挂起直至服务端进程返回数据，所有如果一个远程方法很耗时，那么就不能在UI线程中发起此远程请求
２．由于服务端的Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现
３．当服务意外终止的时候，Binder连接是断开的，会导致远程服务调用失败，所以客户端可以通过调用`Binder`的`linkToDeath`方法，绑定`IBinder.DeatchRecipient`监听器




进程间通信－－IPC
1.Intent方式
缺点：
传递的数据不能太大，对象数据需要支持序列化

假如Ａ进程要把计算结果传递给Ｂ进程，可以尝试把Ａ进程的计算转移到Ｂ进程的后台服务中进行，这样Ｂ进程可以在服务计算完数据之后直接获取

2.共享文件方式
可以是json/xml这种约定格式的文件，也可以是对象对接
虽然`SharedPreferences`也是写入文件，但是它在内存中有缓存，多进程操作会导致数据不一致

3.Messenger方式
4.AIDL方式