***参考：***

- **[JVM的内存区域划分（面试问题：你了解java内存模型么）](https://blog.csdn.net/hxpjava1/article/details/55189077)**
- **Android应用性能优化最佳实践**

<br/>
### 一、什么Runtime Data Area（运行时数据区） ###

首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。

在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。

因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

<br/>
### 二、Runtime Data Area（运行时数据区） 包括哪几部分 ###

根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：

- 程序计数器（Program Counter Register）
- Java栈（VM Stack）
- 本地方法栈（Native Method Stack）
- 方法区（Method Area）
- 堆（Heap） 

JVM中的运行时数据区应该包括这些部分。在JVM规范中虽然规定了程序在执行期间运行时数据区应该包括这几部分，但是至于具体如何实现并没有做出规定，不同的虚拟机厂商可以有不同的实现方式。

<br/>
### 三、Runtime Data Area（运行时数据区） 的每部分到底存储了哪些数据 ###

**1.程序计数器**

<br/>
**2.Java栈**

Java栈也称作虚拟机栈（Java Vitual Machine Stack），也就是我们常常所说的栈，跟C语言的数据段中的栈类似。事实上，Java栈是Java方法执行的内存模型。

<br/>
**3.本地方法栈**

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。**在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。**

<br/>
**4.堆**

Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。**因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。**

<br/>
**5.方法区**

方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。**在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。**

在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

**在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。**

**在JVM规范中，没有强制要求方法区必须实现垃圾回收。**很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。


<br/>
### 四、Runtime Data Area（运行时数据区） 的内存回收机制 ###

Android系统针对ART虚拟机的堆，采用Generation Heap Memory模型来管理。

- Youngth Generation： GC频率比较高，而且也分为几个小区-Eden/S0/S1; GC算法采用copy算法

- Old Generation : GC频率比较低， GC算法采用标记算法

- Persistent： GC频率最低 




<br/>
### 五、优化内存的意义 ###

- 减少GC时导致的卡顿

- 减少内存碎片

- 避免OOM

OOM的引起，主要是因为内存泄漏和内存碎片。

**通过DDMS查看heap信息时，下面的列表有个free行，该行数值越大，表示内存碎片越多** 