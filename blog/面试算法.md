## 一、找出数组中出现次数超过一半的数 ##

这个算法的时间复杂度是O(n)，另外用了两个辅助变量。

通过打擂台的形式，最后保存的变量为**出现次数超过一半的数**

    private int getValue() {
        int[] array = {1, 3, 3, 3, 3, 2, 4};
        int count = 0;
        int result = array[0];
        for (int i = 0; i < array.length; ++i) {
            if (count == 0 || result == array[i]) {
                result = array[i];
                ++count;
            } else {
                --count;
            }
        }
        return result;
    }


<br/>

## 二、把1~1000拼接成字符串，求7出现的个数（腾讯面试过，美团也出过） ##

添加把数字添加前缀0，让数字长度相等,问题就转换成000 ~ 999, 拼接成字符串，求7出现的次数

        000
        001
        ...
        010
        011
        ...
        100
        101
        ...
        998
        999

000~999拼接成字符串，总共1000 * 3 个数字，0~9中每个数字出现的次数是一样的。

那么7出现的次数为 （1000 * 3）/ 10 = 300 次， 再加上1000又出现1次，总共301次。

<br/>

其实针对x属于[1, 9]，因为 x = 0 不符合下列规律，需要单独计算,都有如下规律：

|    |     x出现的次数      |
|----------|:-------------:|
| 1~10 |  个位出现1次 |
| 1~100 |    十位出现10次   |
|  1~1000 | 百位出现100次 |


对n=abcde进行编号，从右边往左边数分别e是第0位，d是第1为，...


当前是第i位,当前位、低位、高位的值分别如下，当前位出现x的次数受该三个数值的影响。

    factor = 10^i;
    iLowerNum = n - (n/factor)*factor;
    iCurNum = (n/factor)%10;
    iHigherNum = n/(factor*10);
    
例如，求1到2593的整数中，5出现的次数。


|  i  |     iHigherNum      |     iCurNum      |     iLowerNum      |     count      |
|----------|:-------------:|:-------------:|:-------------:|:-------------:|
| 0 | 259  | 3 |  0 |  259*10^i |
| 1 |  25 |  9 |  3 |  (25+1)*10^i |
| 2 |  2 |  5 |  93 |  2*10^i + 93 +1 |
| 3 | 0  |  2 |  593 |  0*10^i |
| |  |  |  |  813 |

例如，求1到1000的整数中，1出现的次数。


|  i  |     iHigherNum      |     iCurNum      |     iLowerNum      |     count      |
|----------|:-------------:|:-------------:|:-------------:|:-------------:|
| 0 | 100  | 0 |  0 |  100*10^i |
| 1 |  10 |  0 |  0 |  10*10^i |
| 2 |  1 |  0 |  0 |  1*10^i |
| 3 | 0  |  1 |  0 |  0*10^i + 1 |
| |  |  |  |  301 |



## 三、判断一个链表是否成环  ##

定义两个哨兵：p1和p2， p1每次走一步，p2每次走两步

如果链表有环，那么遍历会没有终点，p1会赶上p2,即存在p1=p2这种情况



<br/>

## 四、格雷码的生成  ##

![](../img/graycode.png)

可以根据规则生成格雷码，也可以根据规定递归生成




<br/>

## 五、位运算符  ##


**异或的运算**

![](../img/xor.png)

<br/>
#### 交换两个整数的值 ####


        int a = 9;
        int b = 11;

        a=a^b; 1001^1011=0010
        b=b^a; 1011^0010=1001
        a=a^b;  0010^1001=1011

        //结果
        a = 11;
        b = 9;

<br/>
#### 正整数的二进制表示中1的个数 ####

>把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0

    int count(int n) {
        int num = 0;
        while (n) {
            n &= (n - 1);
            num++;
        }
        return num;
    }


<br/>
#### 两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。 ####

> 结合上面的知识， 求这两个数的异或， 然后统计异或结果中1的位数



<br/>
#### 用一条语句判断一个整数是不是2的整数次方 ####

一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其它所有位都是0 。 根据前面的分析，把这个整数减去1后再和它自己做与运算，这个整数中唯一的1就变成0了。
>!（x & (x - 1)）

**负整数还要额外处理下**


<br/>
#### 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字 ####

两个相同的整数异或结果为0， 数组中所有数异或之后，结果是出现一次的两个整数a和b的异或结果。

然后把数组分成两部分：和a的二进制中最低位为1的位置相同的数当成一组新数组。

问题就转换成**一个整型数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字**